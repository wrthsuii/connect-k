# Аналіз реалізації гри "Connect-K" у різних парадигмах

Цей документ містить детальне порівняння трьох реалізацій логіки гри «k-в-ряд» на довільному полі з перешкодами та штучного інтелекту (алгоритм MinMax з Alpha-Beta відсіканням) у різних парадигмах програмування.

## Зведений огляд архітектур

| Характеристика | Prolog (Логічна) | Python (ООП/Імперативна) | Haskell (Функційна) |
| :--- | :--- | :--- | :--- |
| **Управління станом** | Незмінне (через аргументи) | Мутабельне (властивості класу) | Незмінне (генерація нових копій) |
| **Механізм перебору** | Вбудований Backtracking | Явні цикли (`for/while`) | Хвостова та взаємна рекурсія |
| **Безпека типів** | Динамічна (Runtime) | Динамічна (Runtime) | Строга статична (Compile-time) |

---

## Детальний розбір за парадигмами

### 1. Декларативне ядро на Prolog
Логічне програмування дозволяє описати правила гри як набір істинних тверджень (фактів), залишаючи пошук розв'язку самій мові.

* **Особливості представлення:** Дошка передається як список списків. Замість зміни стану, кожен хід породжує нову гілку `NewBoard`.
* **Сильні сторони:**
    * **Ідеальна сумісність із деревом рішень:** механізм MinMax природно лягає на логічний бектрекінг.
    * **Універсальність правил:** перевірка "чи є $K$ фішок підряд" описується декларативно без прив'язки до конкретного розміру матриці.
* **Недоліки:**
    * Модифікація списків (симуляція падіння фішки) працює за $O(N)$ і потребує рекурсивної перебудови елементів.
    * Інтеграція з веб-серверами (через `pyswip`) вимагає однопотокового режиму.

### 2. ООП-рушій на Python
Класичний підхід, де гра є об'єктом, що змінює свій стан у часі.

* **Особливості представлення:** Матриця інкапсульована в класі `ConnectK`. Будь-яка дія безпосередньо змінює значення `self.board[r][c]`.
* **Сильні сторони:**
    * Максимальна швидкість написання та найменший обсяг коду (лише 93 рядки).
    * Миттєвий доступ до комірок масиву за $O(1)$.
    * Прозорість логіки завдяки звичним імперативним інструкціям (цикли `for`, `while`).
* **Недоліки:**
    * Необхідність писати логіку перебору (MinMax) повністю з нуля.
    * Створення копій об'єктів (`copy.deepcopy()`) під час рекурсії ШІ створює навантаження на пам'ять $O(d \times N \times M)$.

### 3. Чиста функційність на Haskell
Математично точний підхід, який унеможливлює побічні ефекти та непередбачувані зміни стану дошки.

* **Особливості представлення:** Дошка — незмінний список `[[Int]]`. Використовуються функції вищого порядку та композиція.
* **Сильні сторони:**
    * **Математична елегантність:** використання вбудованого функціоналу (наприклад, `transpose` для обробки вертикалей та діагоналей).
    * **Надійність:** відсутність побічних ефектів гарантує, що симуляція ходів ШІ не "зламає" поточний стан дошки гравця.
    * **Безпека типів:** монада `Maybe` гарантує безпечну обробку ситуацій, коли можливих ходів більше не залишилось.
* **Недоліки:**
    * Високий когнітивний поріг входження для розррбника (абстракції, функтори).
    * Постійна генерація нових структур даних у пам'яті.

---

## Детальне порівняння компонентів

### Представлення дошки та взаємодія

| Аспект | Prolog | Python | Haskell |
|--------|--------|--------|---------|
| **Мутабельність** | Незмінні списки | Мутабельні списки (List) | Незмінні списки (List) |
| **Падіння фішки** | Рекурсивна заміна рядка | Пряме присвоєння `board[r][c] = p` | Спліт списку та конкатенація |
| **Доступ до комірки**| `nth0/3` (Складність O(N)) | Індекс `[r][c]` (Складність O(1)) | Оператор `!!` (Складність O(N)) |

### Логіка штучного інтелекту (MinMax)

| Аспект | Prolog | Python | Haskell |
|--------|--------|--------|---------|
| **Цикл перебору** | Вбудований Backtracking | Цикл `for move in valid_moves` | Взаємна рекурсія (`maximize` / `minimize`) |
| **Симуляція ходу** | Передача `NewBoard` у предикат | Глибоке копіювання `copy.deepcopy()` | Чиста функція `makeMove` |
| **Оцінка ліній** | `findall` для розбиття на вікна | Вкладені імперативні цикли | `concatMap` та композиція функцій |

---

## Альтернативні підходи (Що можна покращити)

### Інші алгоритми ігрового ШІ
1. **Monte Carlo Tree Search (MCTS):** Замість повного перебору грає тисячі випадкових партій до кінця. Ефективніше для великих дощок, де фактор розгалуження робить MinMax надто повільним.
2. **Жадібний алгоритм (Greedy Search):** Аналізує лише поточний хід (Depth = 1). Надзвичайно швидкий, але не вміє передбачати пастки суперника.

### Способи оптимізації MinMax
1. **Memoization (Transposition Tables):** Збереження вже оцінених позицій дошки (наприклад, у хеш-таблиці в Python або через `asserta` у Prolog). Дозволяє уникнути повторного аналізу одних і тих самих станів.
2. **Move Ordering (Впорядкування ходів):** Змушує ШІ спочатку аналізувати центральні стовпці. Це кардинально прискорює Alpha-Beta відсікання, бо "найкраща" гілка знаходиться швидше.

### Структури даних для дошки
1. **Bitboards (Бітові дошки):** Дошка кодується як велике ціле число. Перевірка перемоги виконується за мікросекунди за допомогою побітових зсувів (`<<`, `>>` та `AND`). Це галузевий стандарт для шахових рушіїв.
2. **Одновимірний масив (1D Array):** Матриця N x M розгортається в масив довжиною N*M. Прискорює доступ до пам'яті (кеш процесора) порівняно зі списками списків.

---

## Висновки: Коли яку парадигму обрати?

1. **Prolog, якщо:**
   * Мета — формалізувати складні правила гри або експертної системи.
   * Задача потребує глибокого пошуку в просторі станів.
   * Зосередження на логіці *"Що таке перемога?"*, а не *"Як керувати пам'яттю?"*.

2. **Python, якщо:**
   * Потрібне швидке прототипування та інтеграція з сучасними веб-фреймворками (Flask, FastAPI).
   * Вимога проєкту — максимальна швидкість написання та прозорість коду.
   * Гра є лише частиною великого застосунку.

3. **Haskell, якщо:**
   * Проєкт вимагає 100% математичної гарантії відсутності побічних ефектів.
   * Необхідна надійна та безпечна багатопотоковість.
   * Пріоритетом є функційна архітектура та строга типізація.
